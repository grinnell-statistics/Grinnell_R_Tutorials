---
title: "Lab #1 - Introduction to `R`"
output:
  html_document:
    toc: true
    toc_float:
      collapsed: true
      smooth_scroll: false
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This lab introduces `R` and `R Studio` as well as the format of future class sessions.

**Directions** (read before starting)

1) Please *work together* with your assigned partner. Make sure you both fully understand something before moving on.
2) Record your answers to lab questions separately from the lab's examples. You and your partner should only turn in responses to lab questions, nothing more and nothing less.
3) Ask for help, clarification, or even just a check-in if anything seems unclear.

$~$

## Preamble

The "Preamble" section of labs is something we'll go through together at the start of class.

The "Lab" section is something you will work on with a partner using *paired programming*, a framework defined as follows:

- One partner is the *driver*, who physically writes code and operates the computer
- One partner is the *navigator*, who reviews the actions of the driver and provides feedback and guidance

Partners are encouraged to switch roles throughout the "Lab" section, but for the first few labs the less experienced coder should spend more time as the *driver*.

$~$

### The Layout of R Studio

After you open `RStudio`, the first thing you'll want to do is open a file to work in. You can do this by navigating: File -> New File -> RScript, which will open a new window in the top left of the `RStudio` interface for you to work in.  At this point you should see four panels:

1. Your R Script (top left)
2. The Console (bottom left)
3. Your Environment (top right)
4. The Files/Plots/Help viewer (bottom right)

An *R Script* is like a text-file that stores your code while you work on it.  At any point you can send some or all of the code in your *R Script* to the *Console* to execute.  You can also type commands directly into the *Console*.  The *Console* will echo any code you run, and it will display any textual/numeric output generated by your code.

The *Environment* shows you the names of data sets, variables, and user-created functions that have been loaded into your work space and can be accessed by your code.  The *Files/Plots/Help Viewer* will display graphics generated by your code and a few other useful entities (like help documentation and file trees).

**Question #0**: Create a blank *R Script*. You will use this *R Script* to record your answers to future questions in this document.

$~$

### Using R

`R` is an interpreted programming language, which allows you to have the computer execute any piece of code contained your *R Script* at any time without a lengthy compiling process. 

To run a single piece of code, simply highlight it and either hit *Ctrl-Enter* or click on the "Run" button near the top right corner of your R Script. You should see an echo of the code you ran in the *Console*, along with any response generated by that code.

```{r}
4 + 6 - (24/6)
```

```{r}
5 ^ 2 + 2 * 2
```

The examples shown above demonstrate how `R` can be used as a calculator. However, most of code we will write will rely upon **functions**, or pre-built units of code that translate one or more *inputs* into one or more *outputs*.

```{r}
log(x = 4, base = 2)
```

The example above demonstrates the `log()` function. The input named "x" is set to be 4, and the input named "base" is set to 2. The labels given to these inputs, "x" and "base", are the function's **arguments**. The function returns the output "2", which is $\text{log}_2(4)$. Note that `log(4, 2)` will also produce the output "2" as any unlabeled inputs are mapped to arguments in the order defined by the creator of the function.

$~$

### Help Documentation

You'll eventually end up memorizing the arguments of common `R` functions; however, while you're learning I strongly encourage you to read the *help documentation* for any `R` function used in your code. You can access a function's documentation by typing a `?` in front of the function name and submitting to the console.

```{r, eval = FALSE}
?log
```

$~$

### Adding Comments

When coding, it is good practice to include comments that describe what your code is doing. In `R` the character "#" is used to start a comment.  Everything appearing on the same line to the right of the "#" will not be executed when that line is submitted to the *console*.

```{r}
# This entire line is a comment and will do nothing if run
```

```{r}
1:6 # The command "1:6" appears before this comment
```

In your *R Script*, comments appear in green. You also should remember that the "#" starts a comment *only for a single line* of your R Script, so long comments requiring multiple lines should each begin with their own "#".

$~$

## Lab

The remainder of the lab is to be completed by you and your lab partner. You should work at a comfortable pace that ensures both of you thoroughly understand the lab's contents and examples.

$~$

### Loading Data

An important part of data science is *reproducibility*, or the ability for two people to independently replicate the results of a project.

To ensure reproducibility, every data analysis should begin by importing raw data into `R` and manipulating it used documented (commented) code. Further, the raw data should be imported using functions, such as `read.csv`, instead of the point and click interface provided by the "Import Dataset" button (at the top of the environment pane).

Below are two different examples:

```{r, eval = FALSE}
## Loading a CSV file from a web URL (storing it as "my_data")
my_data <- read.csv("https://some_webpage/some_data.csv")
```

```{r, eval = FALSE}
## Loading a CSV file with a local file path
my_data <- read.csv("H:/path_to_my_data/my_data.csv")
```

A few things to note.

1) Both `<-` or `=` can be used to *assign* something to a named object. The `<-` operator will create the object globally, while `=` will create the object locally in the environment where it was used. For the purposes of this course, we can use the two interchangeably since our code will "live" in the global environment.
2) File paths must use  `/` or `\\`. A single `\` is used by `R` to start an instance of a special text character. For example, `\n` creates a new line in a string of text.

**Question #1 (Part A)**: Add code to your script that uses the `read.csv()` function to create an object named `my_data` that contains the "Happy Planet" data stored at: https://remiller1450.github.io/data/HappyPlanet.csv

After running your Question #1 code, an entry named "my_data" should appear in the Environment panel (top right).

You can click on the small arrow icon to reveal the data's structure, or you can click on the object's name to *view* the data in spreadsheet format.

**Question #1 (Part B)** Inspect the structure of `my_data` and view the data set in spreadsheet format. In an `R` comment, briefly describe how this data set is structured (ie: what does each row and column represent, what are some of the columns, etc.)

$~$

### Objects and Assignments

`R` stores data in containers called *objects*. Data is *assigned* into an object using `<-` or `=`. After assignment, data can be referenced using the object's name. The simplest objects are *scalars*, or a single *elements*:

```{r}
x <- 5 # This assigns the integer value '5' to an object called 'x'
x^2    # We can now reference 'x'
```

`R` stores sequences of elements in objects called *vectors*:

```{r}
x <- 1:3 # The sequence {1, 2, 3} is assigned to the vector called 'x'
print(x)
y <- c(1,2,3) # The function 'c' concatenates arguments (separated by commas) into a vector
print(y)
z <- c("A","B","C") # Vectors can contain many types of values
print(z)
```

The three most important *types* of vectors are:

1) *numeric vectors* - for example: `x = c(1,2,3)`
2) *character vectors* - for example: `x = c("A","B","C")`
3) *logical vectors* - for example: `x = c(TRUE, FALSE, TRUE)`

You should always consider a vector's type before using it. Many functions expect specific input types and will produce an error if the wrong type is used.  You can check the type of an object using the `typeof()` function:

```{r}
chars <- c("1","2","3") # Create a character vector
typeof(chars)

nums <- c(1,2,3) # Create a numeric vector
typeof(nums)

mean(chars) # This produces an error, mean() only works for numeric vectors
mean(nums) # This works as intended
```

Certain `R` functions are *vectorized*, meaning they can accept a scalar input, for example `1`, and return the scalar output `f(1)`, or they can accept a vector input, such as `c(1,2,3)`, and return the vector `c(f(1),f(2),f(3))`. For example, `sqrt()` is vectorized:

```{r}
nums <- c(1,2,3,4)
sqrt(nums)
```

Data are usually stored in objects called *data.frames*, which are composed of several vectors of the same length:

```{r}
DF <- data.frame(A = x, B = y, C = z) # Creates a data.frame object 'DF'
print(DF)
```

Functions like `read.csv()` will automatically store their output as a data frame:

```{r}
my_data <- read.csv("https://remiller1450.github.io/data/HappyPlanet.csv")
typeof(my_data)
```

However, notice `typeof()` describes `my_data` as a *list* object. Lists are a flexible class of objects whose elements can be of any type. A data frame is a special case of a list. 

Shown below is an example list containing three components, two different data frames and the character string "ABC":

```{r}
my_list <- list(my_data, DF, "ABC")
```


**Question #2**: Create a data frame named `my_DF` containing two vectors, $J$ and $K$, where $J$ is created using the `seq` function to be a sequence from 0 to 100 counting by 10 and $K$ is created using the `rep` function to replicate the character string "XYZ" the proper number of times.  *Hint*: read the help documentation for each function (`seq` and `rep`) to determine the necessary arguments.

$~$


### Indexing

Suppose we have a vector "x" and would like to extract the element in its second position and assign it to a new object called "b":

```{r}
x <- 5:10
b <- x[2]
b
```

The square brackets, `[` and `]`, are used to *access* a certain position (or multiple positions) within an object. In this example we access the second position of the object "x".

Some objects, such as data frames, have multiple dimensions, requiring indices in each dimension (separated by commas) to describe a single element. A few examples are shown below:

```{r}
DF <- data.frame(x = x, y = y, z = z) 
DF[2,3] # The element in row 2, column 3
DF[2,] # Everything in row 2
```

For list objects, double square brackets, `[[`, are used to access positions within the list:

```{r}
my_list[[2]] ## The 2nd component of the list
```

**Question #3**: Use indices to print the Happiness score (column #3) of Hong Kong (row #57) in the object `my_data` (the Happy Planet data from Question #1). Be sure your code does not print any other information about this observation.

$~$

### Working with Data

Suppose we want to access a single variable from a data set, there are a few different ways we can do so:

```{r}
# The $ accesses the component named 'Country' within 'my_data'
countries <- my_data$Country  

# Position indexing to access the variable 'Country' (since its the first column)
countries2 <- my_data[,1] 

# Use the name of the variable in place of an index position
countries3 <- my_data[,'Country']
```

Suppose we want to access a single observation (data point) in our dataset:

```{r}
Albania <- my_data[1,] # This stores the entire first row
```

Suppose we want a range of observations:

```{r}
FirstFive <- my_data[1:5,] # This stores the first five rows
head(FirstFive)
```

The `head` function prints the first few rows and variables of an object. Here are a few other functions might use when working with a new data set:

```{r}
dim(my_data) # prints the dimensions of 'my.data'
nrow(my_data) # prints the number of rows of 'my.data'
ncol(my_data) # prints the number of columns of 'my.data'
colnames(my_data) # prints the names of the variables (columns) of 'mydata'
```

**Question #4 (Part A)**: Write code that prints the populations of the last three observations (countries) that appear in the Happy Planet data.

**Question #4 (Part B)**: Write code that finds the median value of the "LifeExpectancy" variable *for the last 10 observations* in the Happy Planet data.

$~$

### Logical Conditions and Subsetting

Often we want to access all data that meet certain criteria. For example, we may want to analyze all countries with a life expectancy above 80. To accomplish this, we'll need to use logical operators:

```{r, eval = FALSE}
## This returns a logical vector using the condition "> 80"
my_data$LifeExpectancy > 80
```

A few logical operators you should know of are:

Operator | Description 
---------|-------------
`==`     | equal to
`!=` | not equal to
`>` | great than 
`>=` | greater than or equal to 
`< `| less than
`<= `| less than or equal to
`& `| and
`| `| or  
`! ` | negation ("not") 

The `which()` function can be used to identify the indices of elements of within an object containing the logical value `TRUE`, for example:

```{r, eval = FALSE}
## This returns the positions where the condition evaluated to TRUE
which(my_data$LifeExpectancy > 80 )
```

This result could then be used as indices to subset `my_data`:

```{r, eval = FALSE}
## sub-setting via indices
keep_idx <- which(my_data$LifeExpectancy > 80)
my_subset <- my_data[keep_idx, ]
```

The approach shown above is a bit cumbersome. As an alternative we can use the `subset()` function alongside logical expressions:

```{r}
## Example #1
Ex1 <- subset(my_data, LifeExpectancy > 80)
```

In example #1, the data frame `Ex1` will contain the subset of countries with life expectancy above 80. Notice how the `subset()` function knows that `LifeExpectancy` is a component of `my_data`.

```{r}
## Example #2
Ex2 <- subset(my_data, LifeExpectancy <= 70 & Happiness > 6)
```

In example #2, the `&` operator is used to create a data frame, `Ex2`, containing all countries with a life expectancy of 70 or below *and* a happiness score above 6.

```{r}
## Example #3
Ex3 <- subset(my_data, LifeExpectancy <= 70 | Happiness > 6)
```

In example #3, the `|` operator is used create a data frame of all countries with a life expectancy of 70 or below *or* a happiness score above 6. Notice the different dimensions of `Ex2` and `Ex3`:

```{r}
dim(Ex2)
dim(Ex3)
```

**Question #5**: Create a data frame named "Q5" that contains all countries with a population over 100 million that also have a happiness score of 6 or lower. Then, print the number of rows of this data frame.

$~$

### Data Summaries

Descriptive summaries are an essential component of any data analysis. A few functions used to calculate several basic numerical summaries are shown below:

```{r}
mean(my_data$LifeExpectancy) # mean
sd(my_data$LifeExpectancy) # standard deviation
min(my_data$LifeExpectancy) # minimum
max(my_data$LifeExpectancy ) # maximum
quantile(my_data$LifeExpectancy, probs = .35) # the 35th percentile
```

Each of these functions operates on a single variable. For a broader set of summary statistics, you can input an entire data frame into the `summary()` function:

```{r}
summary(my_data)
```

Notice how `summary()` is not particularly useful *categorical variables*. For these variables you should be using *frequency tables*.

A *one-way frequency table* shows the frequencies of categories in a single categorical variable, while a *two-way frequency tables* shows the relationship between two categorical variables. Both are created by the `table()` function:

```{r}
table(my_data$Region) # A one-way frequency table of 'region'
table(my_data$Region, my_data$LifeExpectancy > 80) # A two-way frequency table showing the number of countries w/ LifeExpectancy > 80 by region
# Notice how the table function can use numeric, logical, and character variables
```

Tables are their own type of object, and they can be used as an input to functions like `barplot()`:

```{r, fig.height= 3, fig.width= 4}
my_table <- table(my_data$Region) # Tables can be stored as objects
barplot(my_table) # Creates a bar plot from a table
```

They can also be used as an input to the `prop.table()` function to find row or column proportions:

```{r}
prop.table(my_table, margin = 1) # "margin = 1" gives row props, "margin = 2" gives column props 
```

In the example above, the table only had a single dimension (so each row total was the same as the frequency). Shown below is a more typical example:

```{r}
my_table <- table(my_data$Region, my_data$LifeExpectancy > 80)
prop.table(my_table, margin = 1)
```

Notice how this example used a logical condition to construction a binary variable to serve as the columns in the table.

**Question #6**: Find the mean, median, and range (maximum - minimum) of the variable `LifeExpectancy` in the Happy Planet data. Briefly comment on whether the distribution of this variable seems to be symmetric or skewed using plain text beneath your answer's code chunk.

$~$

### Practice (required)

*The College Scorecard* is a government database that record various characteristics of accredited colleges and universities within the United States. A portion of this database containing 2019-2020 data on colleges that primarily award undergraduate degrees and had at least 400 full time students is available at the URL below:

https://remiller1450.github.io/data/Colleges2019.csv 

You will use these data in Question #7 (below).

**Question #7**: 

- **Part A**: Load these data into `R` and store them as a data.frame object named `colleges`.
- **Part B**:  Create a subset of `colleges` that admit fewer than 25% of applicants (as measured by "Adm_Rate"). Store this subject in an object named `colleges_selective`.
- **Part C**: Using the subset you created in Part B, `colleges_selective`, construct a table containing the proportion of private colleges within each region.
- **Part D**: Provide a 1-sentence interpretation of one of the proportions in your table (you may choose which one seems most interesting).

```{r, echo = FALSE, eval = FALSE}
## Part A
colleges <- read.csv("https://remiller1450.github.io/data/Colleges2019.csv")

## Part B
colleges_selective = subset(colleges, Adm_Rate < 0.25)

## Part C
selective_table = table(colleges_selective$Region, colleges_selective$Private)
prop.table(selective_table, margin = 1)
```

