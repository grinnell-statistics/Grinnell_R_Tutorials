---
title: "Introduction to Coding in `R`"
output:
  learnr::tutorial:
    progressive: true
    allow_skip: true
runtime: shiny_prerendered
description: 
 "This tutorial provides a very brief introduction to some basic `R` programming."
---

```{r setup, include=FALSE}
library(learnr)
library(mosaic)
x <- 1:3
y <- c(8, 3.2, 6/5)
z <- c("A", "B", "C")
vec.1 <- c("6", "2", "7", "4")        # Create a character vector
vec.2 <- c(5, 7, 3, 4)                # Create a numeric vector
vec.3 <- as.numeric(vec.1)            # Create a numeric vector
DF <- data.frame(aa = vec.1, bb = vec.2, cc = vec.3) 
# Creates a data.frame object named 'DF' consisting of the three vectors x, y, and z from above
char <- "A"                           # create a character element
num <- 5                              # create a numeric element
lst <- list(3, 3.14159, "pi", TRUE)   # Creates a list of different data types
my_data <- read.csv("https://raw.githubusercontent.com/skuiper/GrinnellDataScience/master/data/IowaCityHomeSales.csv")
```



## **Using `R`**

This online tutorial is designed to introduce you to basic commands in `R` and `RStudio`. This website will allow you to edit and execute `R` code and see the results within your browser. In a future tutorial we will show you how to create and run your own scripts from your computer. In R, text and coding are often separated. The places where we type our code are called `Code Chunks`.

### *`R` as a Calculator*

At its most basic level, `R` can be used to perform arithmetic operations. A few examples are shown below. Try hitting the "run code" button to execute the following commands on your own.

```{r calculator1, exercise = TRUE}
5 + 1 - 2
```

```{r calculator2, exercise = TRUE}
5^2 + 2 * 2
```

As with many calculators, the operators are $+$ for addition, $-$ for subtraction, $*$ for multiplication, $/$ for division and ^ for exponentiation. As usual, parentheses are used to clarify the order of operations.

#### **Question # 1:**

What happens if you type `(5 ^ 2 + 2) * 2` into the code chunk below?

```{r calculator3, exercise = TRUE}


```


#### Functions within `R`

Some arithmetic operations require the use of *functions*, or pre-built units of code that translate one or more *inputs* into one or more *outputs*. In the example below, the function `exp` raises the number $e = 2.718$ to the power that is passed to the function. The power is the input variable and it is passed to the function via the parentheses. In this example, the numbera 1 and 2 are input into the `exp` function (i.e. $e^{1}$ and $e^{2}$):

```{r functions1, exercise = TRUE}
exp(1)

exp(2)
```

The following function takes the square root:

```{r functions2, exercise = TRUE}
sqrt(4)
```

This function takes the absolute value:

```{r functions3, exercise = TRUE}
abs(-3)
```


#### **Question # 2:**

You can use multiple functions in one line. For example, type `log(exp(3))` into the code chunk below?

```{r functions4, exercise = TRUE}


```


### Help Documentation

A nice aspect of `R` is the documentation of several functions. While you are getting started with R, it is important to read the help documentation for `R` functions used in your code. You can access a function’s documentation by typing a `?` in front of the function name and executing the command. For example, if you have questions about taking the log of a number you can type `?log` into the line of code.

```{r documentation, exercise = TRUE}
?log
```

### Including Comments

When coding, it is good practice to include comments that describe what your code is doing, or to leave notes for yourself. 
In `R`, the character “#” is used to start a comment. Everything appearing on the same line to the right of the “#” will not be executed.

```{r comment1, exercise = TRUE}
# This entire line is a comment and will do nothing if run

```

```{r comment2, exercise = TRUE}
1:6 # The command "1:6" appears before this comment

```

In `R`, comments appear in green. You also should remember that the "#" character starts a comment *only for a single line* of your `R` script, so long comments requiring multiple lines should each begin with their own “#”.

## **Data Types and Structures**

In `R` it is important to understand data types and data structures. Improper use of data types is one of the most common mistakes made by beginning users.

### Data Types

`R` objects have five basic classes:

Class         | Examples
------------- | ------
**integer**   | $0, 1, 2, 3$
**numeric**   | $2, 3.12, \pi$
**logical**   | TRUE, FALSE
**complex**   | $3 + 0i$, $1 + 2i$
**character** | "abc", "a", "sale price"

#### Object Assignment

`R` stores data in containers called *objects*. Data is assigned into an object using `<-` or `=`. For the purposes of this course, we can use the two interchangeably. After assignment, data can be referenced using the object’s name.


#### Scalars

The simplest objects are *scalars*, or a single *element*:

```{r scalar1, exercise = TRUE}
x <- 5 # This assigns the integer value '5' to the variable called 'x'.
       # Note that defining 'x' produces no output.
x      # We simply type "x" to see it's value
x^2    # We can now reference 'x'
```

You should always consider a variables’s type before using it. Many functions expect specific input types and will produce an error if the wrong type is used.

```{r scalar2a, exercise = TRUE, error = TRUE}
char = "A" # Create a character element
char
sqrt(char)  # This produces an error, sqrt only works for numeric elements
```

```{r scalar2b, exercise = TRUE}
num <- 5   # Create a numeric element
num
sqrt(num)  # This works as intended
```

You can check the type of an object using `class` function:

```{r scalar3, exercise = TRUE}
class(char)
class(num)
```


### Data Structures

`R` also has several **data structures**, or collections of data types. Listed below are a few examples:

Structure      | Description
-------------- | -----------------------------------------------
**scalar**     | A single element
**vector**     | A set of values of the same type and or class (e.g. numeric, character, date, etc.).  
**list**       | Represented as a vector, but can contain objects from different classes
**data frame** | Data frames can have different class types for each column/vector

#### Vectors

`R` stores sequences of the same element types in objects called *vectors*:

```{r vector1, exercise = TRUE}
x <- 1:3  # A vector of integer values, the sequence {1, 2, 3} is assigned to the vector called 'x'
x
```

The function `c` concatenates arguments (separated by commas) into a vector:

```{r vector2, exercise = TRUE}
y <- c(8, 3.2, 6/5) # Use c(), with elements separated by a comma to create a vector
y
```

Vectors can contain many types of values; this is a vector of characters:

```{r vector3, exercise = TRUE}
z <- c("A", "B", "5")  # Any element in "" will be considered a character
z
```

The three most important types of vectors are:

1. *numeric vectors* --- for example: `x = c(1, 2, 3)`
2. *character vectors* --- for example: `x = c("A", "B", "5")`
3. *logical vectors* --- for example: `x = c(TRUE, FALSE, TRUE)`

As with scalars, you should always consider a vector’s type before using it, since many functions having vector inputs expect specific input types.

```{r vector4a, exercise = TRUE}
vec.1 <- c("6", "2", "7", "4") # Create a character vector

vec.1
mean(vec.1)                    # This produces an error, mean() only works for numeric vectors
```

```{r vector4b, exercise = TRUE}
vec.2 <- c(5, 7, 3, 4)          # Create a numeric vector

vec.2
mean(vec.2)                     # This works as intended
```

You can check the type of a vector's objects using the same `class` function:

```{r vector5, exercise = TRUE}
class(vec.1)
class(vec.2)
```

We can use the following function to convert characters to numeric. Similar functions can be used to change numeric to characters or logical objects.

```{r vector6, exercise = TRUE}
vec.3 <- as.numeric(vec.1)
vec.3
mean(vec.3)
```


#### Vectorized Functions

Certain `R` functions are vectorized, meaning they can accept a scalar input or a vector input. For example, if `f` is a vectorized function then you could pass a scalar, i.e. `1`, and the function will return the scalar output `f(1)`. Conversely, you could pass a vector input, such as `c(1, 2, 3)`, and the function will return the vector `c(f(1), f(2), f(3))`. One example of a vectorized function is `sqrt`:

```{r vector7, exercise = TRUE}
vec.2
sqrt(vec.2)
```

#### Lists

Vectors are restricted because they require all elements are the same type. However, lists are a flexible class of objects whose elements can be of any type. Lists can even contain vectors

```{r list1, exercise = TRUE}
lst.1 <- list(3, 3.14159, "pi", TRUE, x, y, z) # Creates a list of different data types including vectors

print(lst.1)

```



#### Data Frames

Data is typically stored in objects called *data.frames*, which are comprised of several vectors of the same length:

```{r dataframe1, exercise = TRUE}

DF <- data.frame(aa = vec.1, bb = vec.2, cc = vec.3) # Creates a data.frame object named 'DF' consisting of three vectors, vec.1, vec.2, and vec.3 
# We names these columns "aa", "bb" and "cc", but any names will work
DF
```

The structure `str` function is useful for describing each variable in a data frame. While the first and third column look identical, `R` will treat them differently because they are different classes.

```{r dataframe2, exercise = TRUE}
str(DF)
```

When working with data frames, we will typically classify the data types as *integer* variables (i.e. the 'y' vector), *numeric* (i.e. the 'z' vector), or *factor* or *character* variables (i.e. the 'z' vector). Factors are special vectors that represent categorical data. Factors can be ordered or unordered and are normally used to group variables into a fixed number of unique categories or *levels*, (e.g. different automakers: "BMW", "Ford", "Honda", etc.).


**Important Notes**

- `R` is case sensitve, meaning the lower case 'x' is a different object than the upper case 'X'.

- The name of an object can be arbitrary and doesn’t carry any inherent coding meaning. However, do not assign new values to well-known objects. For example, `mean`, `vector`, and `pi` are already defined within `R`. If you assign `mean <- 5` you may no longer be able to use the `mean` function to calculate the average of a data set.

- Assignment is not symmetric; i.e. `x = 5` is not interpreted the same as `5 = x`. Similarly, `x <- 5` is not interpreted the same as `5 <- x.



### Indexing Vectors, Lists, and Data Frames

Suppose we setup a vector 'x' and would like to extract the element in its second position and store it as a new object called 'b':

```{r indexing1, exercise = TRUE}
x <- 5:10
b <- x[2]
b
```

The square brackets, `[` and  `]`, are used to *access* a certain position (or multiple positions) within a data structure. In this example we accessed the second element of 'x'.

For some objects, such as data frames, multiple dimensions are needed to specify an element's position. Therefore these objects require indices for each dimension (separated by commas). Here are a few examples:

```{r indexing2, exercise = TRUE}
DF[2,3] # The element in row 2, column 3

DF[2,]  # Everything in row 2, similarly DF[,2] would select the second column
```

For lists, double square brackets, `[[` and `]]`, are used to access positions within the list:

```{r indexing3, exercise = TRUE}
lst.1[6]   # presents what is accessed by single brackets

lst.1[[6]] # presents what is accessed by double brackets
```


#### **Question # 3:**

In the code chunk below, write code that will select the third row of the data frame. Then write code to select the second column of the data frame.

```{r indexing4, exercise = TRUE}
DF

```

##### **Question # 4:**

Write one line of code that finds the mean of the third column of data in the data frame.

```{r indexing5, exercise = TRUE}



```


## **Working with Dataframes**

### Reading in Data

There are many ways to get data into `R`. If a data set is stored somewhere on your computer as a .csv file, you can load it using the R function `read.csv`

The `read.csv` function is also capable of reading .csv files stored on the web. The website https://raw.githubusercontent.com/skuiper/GrinnellDataScience/master/data/IowaCityHomeSales.csv contains a data set that we want to use. The code below reads the data set IowaCityHomeSales.csv from this website and stores it as an object called 'my.data`. 

We can check to see the data were read in correctly using the $head()$ command:


An important part of data science is reproducibility, or the ability for two people to independently replicate the results of a project. To ensure reproducibility, every data analysis should begin by importing raw data into `R` and manipulating it using documented (commented) code.

There are many ways to load data into `R`. Whenever we read in data, we neet to provide a file path that consists of character string, enclosed by quotations. If a data set is stored somewhere on your computer as a .csv (comma separated values) file, you can load it using the `R` function `read.csv`:

   `my.data <- read.csv("H://path_to_my_data/my_data.csv")`

The `read.csv` function is also capable of reading .csv files stored on the web.:

   `my_data <- read.csv("https://some_webpage/some_data.csv")


The website https://raw.githubusercontent.com/skuiper/GrinnellDataScience/master/data/IowaCityHomeSales.csv contains a data set that we want to use. The code below reads the data set IowaCityHomeSales.csv from this website and stores it as an object called `my_data`.

```{r loadingdata1, exercise = TRUE}
my_data <- read.csv("https://raw.githubusercontent.com/skuiper/GrinnellDataScience/master/data/IowaCityHomeSales.csv")
```


Several commands can be used to verify that the data were read into `R`. 

```{r loadingdata2, exercise = TRUE}
str(my_data)   # Describes each variable in a data frame
head(my_data)  # This function prints the first several rows of an object
```

### Accessing Variables (columns)

There are a variety of different ways to access a single variable from a data set:

1. The `$` accesses the variable (i.e. the column) named 'bedrooms' (i.e. the number of bedrooms for each house) within the dataset 'my_data':

```{r, eval = FALSE}
num_bedrooms <- my_data$bedrooms
```

2. A position index can also be used to access the variable 'bedrooms' (it is the sixth column in the dataset):

```{r, eval = FALSE}
num_bedrooms <- my_data[,6]
```

3. The name of the variable may be used in place of a position index to access the column:

```{r, eval = FALSE}
num_bedrooms <- my_data[,'bedrooms']
```

### Accessing Observations (rows)

In statistics we typically use `tidy` data. This means that each row is a unique case (observational unit), each column is a variable, and each cell is a single value. To access a single row in a dataset, simply identify the row of the desired observations:

```{r, eval = FALSE}
first_sale <- my_data[1,] # This stores the entire first row
first_sale
```

To access a range of rows in a dataset, simply identify the rows of the desired observations:

```{r, eval = FALSE}
first_five_sales <- my_data[1:5,] # This stores the first five rows
first_five_sales
```

### Information About the Dataset

When working with a newly loaded dataset there are a few things we might want to know about the object storing the data:

```{r workingdata, exercise = TRUE}
dim(my_data)      # prints the dimensions of 'my_data'
nrow(my_data)     # prints the number of rows of 'my_data'
ncol(my_data)     # prints the number of columns of 'my_data'
names(my_data)    # prints the names of the variables (columns) of 'my_data'
colnames(my_data) # prints the names of the variables (columns) of 'my_data'
```


### Graphs and Summary Statistics

We can use several functions to summarize our data. The following functions are from the `Mosaic package`. Packages will be discussed in the following tutorial.

```{r workingdata1, exercise = TRUE}
favstats(my_data$bedrooms)  # summary statistics for the bedrooms data
tally(my_data$bedrooms)     # counts the number observations for each level of a vector 
mean(my_data$bedrooms)      # mean
median(my_data$bedrooms)    # median
sd(my_data$bedrooms)        # standard deviation
var(my_data$bedrooms)       # variance 
max(my_data$bedrooms)       # maximum
quantile(my_data$bedrooms, .35) # the 35th percentile
```


The mosaic package also includes several graphic options. Below are a few very basic graphs that we can make. Future tutorials will go into much more detail.
```{r workingdata2, exercise = TRUE}
gf_point(sale.amount ~ area.living, data = my_data)  # In this scatterplot, sale.amount is on the y axis and living.area is on the x axis.
gf_boxplot(~ sale.amount, data = my_data)            # When there is no y variable, we leave the code blank before the `~` and list only the x variable.
gf_histogram(~ sale.amount, data = my_data) 
gf_density(~ sale.amount, data = my_data)        
```


### Tables

#### One-way Frequency Tables

One-way frequency tables summarize a single categorical (factor) variable. In this example, the `table` function generates a table that shows the number of houses in each different category (or factor) described by "style":

```{r tables1, exercise = TRUE}
table(my_data$ac)                  # A one-way frequency table of 'style'
```

#### Two-way Frequency Tables

Two-way frequencies tables summarize the relationship between two categorical variables. In this example (also using the `table` function), the "style" factors are further categorized by the number of bedrooms:

```{r tables2, exercise = TRUE}
table(my_data$bedrooms, my_data$ac) # A two-way frequency table of 'bedrooms' and 'style'
              # Notice that 'bedrooms' is stored as a numeric variable, but it still can be used in the table function
```

#### Proportion Tables

Tables can also be used as an input to the `prop.table` function to find row or column proportions. 

```{r tables3, exercise = TRUE}
prop.table(table(my_data$ac)) 
```

In the example above, the table only had a single dimension. The following example displays a more typical usage:

```{r tables4, exercise = TRUE}
prop.table(table(my_data$bedrooms, my_data$ac))
```

The above example finds the proportions of each category. If you sum all the propotions, you should get 100. There are times you will want to find other types of proporsions. In the output from the code below, we find the proportion based on the number of bedrooms. Thus each row will sum to 100. The `margin = 1` uses a logical condition to construction a binary variable to serve as the rows in the table:

```{r tables5, exercise = TRUE}
prop.table(table(my_data$bedrooms, my_data$ac), margin = 1) # margin = 1 gives row proportions, margin = 2 gives column proportions
```


**Important Notes**

1. File paths must use `/` or `\\`. A single `\` should not be used.


2. The data type can influence what functions can be used:

```{r numeric3, exercise = TRUE}
class(my_data$bedrooms)
mean(my_data$bedrooms)
mean(as.numeric(my_data$bedrooms))
mean(as.character(my_data$bedrooms))
```

3. It is possible to reorder the levels of a factor variable (in this case the basement variable) into a more meaningful order:

```{r tables6, exercise = TRUE}
my_data$bsmt <- factor(my_data$bsmt, levels = c("None","Crawl","1/2", "3/4", "Full"))
my_table <- table(my_data$bsmt)
barplot(my_table)
```

## **On Your Own**

The following code chunk reads in the data file "IowaCityHomeSales.csv" from GitHub:

```{r, eval = FALSE}
my_data <- read.csv("https://raw.githubusercontent.com/skuiper/GrinnellDataScience/master/data/IowaCityHomeSales.csv")
```

Complete the following questions:

1. Use the `names` function to list the names of each column in this dataset.
2. Find the 20th percentile of the sale amount (i.e. the 20th percentile of the variable "sale.amount").
3. Create a two-way frequency table using the variables "bsmt" and "attic". 
4. How many levels exist for "bsmt" (i.e. how many distinct values exist for the bsmt variable)? 
5. How many levels exist for "attic"?
6. What style of house has the most fully finished  attics?
7. What is the highest priced home (i.e. find the highest sale.amount)?
8. What is in the 500th row and 5th column?
9. Why can we find the mean of `my_data$sale.amount` but not the mean of `my_data$style`?


```{r OYO, exercise = TRUE}
head(my_data)

```



## **References and Resources**

* See more tutorials at [Stat2Labs](https://stat2labs.sites.grinnell.edu/RTutorials.html).

